<?xml version="1.0" encoding="UTF-8"?>
<simulation xmds-version="2">
	<name>bec_transport</name>
	<author>Jamie Feiss</author>
	<description>
		BEC transport test
	</description>

	<features>
		<auto_vectorise />
		<benchmark />
		<fftw plan="patient" />
		<validation kind="run-time"/>
		<globals>
			<![CDATA[
				const real T_i = 1.0; // Imaginary time duration
				const real T = 10.0; // Evolution time
				const real x_0 = 10.0; // Final position
			]]>
		</globals>
	</features>

    <!-- Define dimensions -->
    <geometry>
        <propagation_dimension>t</propagation_dimension>
        <transverse_dimensions>
			<dimension name="x" lattice="100" domain="(-10, 20)" />
        </transverse_dimensions>
    </geometry>

  	<!-- Initialisation wavefunction -->
	<vector name="wavefunction" type="complex" dimensions="x">
		<components>psi</components>
		<initialisation>
			<![CDATA[
				psi = (1.0 / pow(M_PI, 0.25)) * exp(-pow(x, 2) / 2.0); // ground state of HO
			]]>
		</initialisation>
	</vector>

	<!-- Comparison wavefunction -->
	<vector name="wavefunction_final" type="complex" dimensions="x">
		<components>psi2</components>
		<initialisation>
			<![CDATA[
				psi2 = (1.0 / pow(M_PI, 0.25)) * exp(-pow(x - x_0, 2) / 2.0); // ground state of HO
			]]>
		</initialisation>
	</vector>

  	<!-- Timing function -->
	<computed_vector name="timing_function" dimensions="" type="real">
		<components>lambda</components>
		<evaluation>
			<![CDATA[
				lambda = (t - T_i) / T;
			]]>
		</evaluation>
	</computed_vector>

	<!-- Harmonic trap potential -->
	<vector name="potential" type="real" dimensions="x">
		<components>V</components>
		<initialisation>
			<![CDATA[
				V = pow(x, 2) / 2.0;
			]]>
		</initialisation>
	</vector>

	<!-- Harmonic trap potential -->
	<vector name="potential2" type="real" dimensions="x">
		<components>V2</components>
		<initialisation>
			<![CDATA[
				V2 = pow(x - x_0, 2) / 2.0;
			]]>
		</initialisation>
	</vector>

  	<!-- Moving harmonic trap potential -->
	<computed_vector name="moving_potential" type="real" dimensions="x">
		<components>Vt</components>
		<evaluation>
			<dependencies>timing_function</dependencies>
			<![CDATA[
				Vt = pow(x - lambda * x_0, 2) / 2.0;
			]]>
		</evaluation>
	</computed_vector>

	<sequence>
		<!-- Imaginary time to find ground state -->
		<integrate algorithm="RK4" interval="T_i" steps="10000">
			<samples>0 0 0 0 0</samples>
			<operators>
				<integration_vectors>wavefunction</integration_vectors>
				<dependencies>potential</dependencies>
				<operator kind="ip" constant="yes" type="real" >
					<operator_names>Ltt</operator_names>
					<![CDATA[
						Ltt = -pow(kx, 2) / 2.0;
					]]>
				</operator>
				<![CDATA[
					dpsi_dt = Ltt[psi] - (V + mod2(psi)) * psi;
				]]>
			</operators>
		</integrate>
		
		<!-- GPE -->
		<integrate algorithm="ARK45" interval="T" tolerance="1e-8">
			<samples>1 50 10 0 0</samples>
			<operators>
				<integration_vectors>wavefunction</integration_vectors>
				<dependencies>moving_potential</dependencies>
				<operator kind="ip" constant="yes" type="imaginary" >
					<operator_names>Ltt</operator_names>
					<![CDATA[
						Ltt = -i * pow(kx, 2) / 2.0;
					]]>
				</operator>
				<![CDATA[
					dpsi_dt = Ltt[psi] - i * (Vt + mod2(psi)) * psi;
				]]>
			</operators>
		</integrate>

		<!-- Imaginary time to find ground state -->
		<integrate algorithm="RK4" interval="T_i" steps="10000">
			<samples>0 0 0 1 1</samples>
			<operators>
				<integration_vectors>wavefunction_final</integration_vectors>
				<dependencies>potential2</dependencies>
				<operator kind="ip" constant="yes" type="real" >
					<operator_names>Ltt</operator_names>
					<![CDATA[
						Ltt = -pow(kx, 2) / 2.0;
					]]>
				</operator>
				<![CDATA[
					dpsi2_dt = Ltt[psi2] - (V2 + mod2(psi2)) * psi2;
				]]>
			</operators>
		</integrate>
	</sequence>

	<output>
		<!-- state -->
		<sampling_group basis="x" initial_sample="no">
			<moments>psi_real psi_imag density</moments>
			<dependencies>wavefunction</dependencies>
			<![CDATA[
				psi_real = psi.Re();
				psi_imag = psi.Im();
				density = mod2(psi);
			]]>
		</sampling_group>

		<!-- potential -->
		<sampling_group basis="x" initial_sample="no">
			<moments>p</moments>
			<dependencies>moving_potential</dependencies>
			<![CDATA[
				p = Vt;
			]]>
		</sampling_group>

		<!-- timing function -->
		<sampling_group basis="x(1)" initial_sample="yes">
			<moments>l</moments>
			<dependencies>timing_function</dependencies>
			<![CDATA[
				l = lambda;
			]]>
		</sampling_group>

		<sampling_group basis="x" initial_sample="no">
			<moments>density2</moments>
			<dependencies>wavefunction_final</dependencies>
			<![CDATA[
				density2 = mod2(psi2);
			]]>
		</sampling_group>

		<sampling_group basis="x(0)" initial_sample="no">
			<moments>overlap1 overlap2</moments>
			<dependencies>wavefunction wavefunction_final</dependencies>
			<![CDATA[
				overlap1 = abs(psi)*abs(psi2);
          		overlap2 = abs(conj(psi)*psi2);
			]]>
		</sampling_group>
	</output>
</simulation>