// ********************************************************
// simulation logging

#define _SAMPLE_LOG_LEVEL             (1 << 0)
#define _SEGMENT_LOG_LEVEL            (1 << 1)
#define _PATH_LOG_LEVEL               (1 << 2)
#define _SIMULATION_LOG_LEVEL         (1 << 3)
#define _WARNING_LOG_LEVEL            (1 << 4)
#define _ERROR_LOG_LEVEL              (1 << 5)
#define _NO_ERROR_TERMINATE_LOG_LEVEL (1 << 6)
#define _ALL_LOG_LEVELS        _SAMPLE_LOG_LEVEL|_SEGMENT_LOG_LEVEL|_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL
#define _LOG_LEVELS_BEING_LOGGED (_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL)

#define real Re
#define imag Im

#include <complex>

#undef real
#undef imag


#include <stdio.h>

#define _LOG(logLevel, ...) \
  do { \
    if (logLevel & _LOG_LEVELS_BEING_LOGGED) { \
      if (logLevel & (_ERROR_LOG_LEVEL | _WARNING_LOG_LEVEL)) \
          printf("%s:%i: ", __FILE__, __LINE__); \
      printf(__VA_ARGS__); \
      fflush(stdout); \
      if (logLevel & (_ERROR_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
        exit(logLevel == _ERROR_LOG_LEVEL); \
    } \
  } while (0)

// ********************************************************
// simulation includes

#include <xpdeint_platform.h>
#include <cmath>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <cstdlib>

#if CFG_OSAPI == CFG_OSAPI_POSIX // These are POSIX headers (i.e. non-windows)
  #include <sys/time.h>
#endif // POSIX

#ifdef __APPLE__
  #include <Availability.h>
  #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
    #define OS_OBJECT_USE_OBJC 0 // Don't make dispatch and xpc objects Objective-C objects.
    #include <IOKit/pwr_mgt/IOPMLib.h> // To disable user idle sleep on Mountain Lion
  #endif
#endif

#include <time.h>
#include <list>
#include <vector>
#include <algorithm>

#include <utility>
#include <map>

#if (CFG_COMPILER == CFG_COMPILER_MSVC)
  #define FFTW_DLL
#endif

#include <fftw3.h>
#include <sys/stat.h>
#include <sys/types.h>

#define _xmds_malloc fftw_malloc
#define xmds_free fftw_free

#define H5_USE_16_API
#include <hdf5.h>

#if !defined(HAVE_H5LEXISTS)
htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id)
{
  H5E_auto_t error_func;
  void* error_client_data;
  // Squelch errors generated by H5Gget_objinfo. It will report errors when it can't find an object
  // but that's the purpose of calling it.
  H5Eget_auto(&error_func, &error_client_data);
  H5Eset_auto(NULL, NULL);
  herr_t err = H5Gget_objinfo(loc_id, name, false, NULL);
  H5Eset_auto(error_func, error_client_data);
  if (err >= 0)
    return true;
  else
    return false;
}
#endif

#define H5T_NATIVE_REAL H5T_NATIVE_DOUBLE
#if defined(HAVE_HDF5_HL)
  #include <hdf5_hl.h>
#endif


typedef long integer;
typedef double real;
typedef std::complex<real> XMDSComplexType;

#include <xpdeint.h>

#define complex XMDSComplexType

const complex i(0.0, 1.0);

using namespace std;

#if CFG_COMPILER == CFG_COMPILER_ICC
  //
  // Disable ICC's warning: label was declared but never referenced
  //
  #pragma warning ( disable : 177 )
#endif

inline void *xmds_malloc(size_t size);

// ********************************************************
// DEFINES
// ********************************************************

// ********************************************************
//   Simulation defines
#define _EPSILON 1e-6
#ifndef INFINITY
#define INFINITY HUGE_VAL
#endif

#ifndef MAX
#define MAX(a, b) \
  ({ typeof(a) _a = (a); \
     typeof(b) _b = (b); \
     _a > _b ? _a : _b; })
#endif

#ifndef MIN
#define MIN(a, b) \
   ({ typeof(a) _a = (a); \
      typeof(b) _b = (b); \
      _a < _b ? _a : _b; })
#endif


// ********************************************************
//   Auto-vectorisation defines

#define _MAKE_AUTOVEC_VARIABLE(x) real* const __restrict__ x ## _autovec = (real*) x
#define _AUTOVEC(x) (x ## _autovec)

// ********************************************************
//   Multipath Simulation Driver defines
#define _n_paths 10

// ********************************************************
//   Geometry defines
#define _lattice_x ((int)64)
#define _min_x     ((real)-10)
#define _max_x     ((real)10)
#define _dx        ((real)((_max_x - _min_x)/_lattice_x))

#define _lattice_kx ((int)64)
#define _dkx        (2.0*M_PI/(_max_x - _min_x))
#define _min_kx     (-(_lattice_kx/2) * _dkx)
#define _max_kx     ((_lattice_kx - 1)/2 * _dkx)

// ********************************************************
//   field x defines
#define _x_ndims 1


// vector wavefunction defines
#define _x_wavefunction_ncomponents 1

// vector potential defines
#define _x_potential_ncomponents 1

// ********************************************************
//   field dimensionless defines
#define _dimensionless_ndims 0


// vector timing_function defines
#define _dimensionless_timing_function_ncomponents 1

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) defines
// vector segment1_x_operators_operator0_field defines
#define _x_segment1_x_operators_operator0_field_ncomponents 1

// ********************************************************
//   segment 2 (RK45 adaptive-step integrator) defines
// vector segment2_x_operators_operator0_field defines
#define _x_segment2_x_operators_operator0_field_ncomponents 5

// ********************************************************
//   field mg0_sampling defines
#define _mg0_sampling_ndims 1


// ********************************************************
//   field mg0_output defines
#define _mg0_output_ndims 2


#define _mg0_output_lattice_t ((int)100)
#define _mg0_output_min_t     (_mg0_output_t[0])
#define _mg0_output_max_t     (_mg0_output_t[_mg0_output_lattice_t-1])
#define _mg0_output_dt        (_mg0_output_t[_index_t+1]-_mg0_output_t[_index_t])

// vector raw defines
#define _mg0_output_raw_ncomponents 3

// vector processed defines
#define _mg0_output_processed_ncomponents 3


// ********************************************************
// GLOBALS
// ********************************************************


// ********************************************************
//   Simulation globals

string gsArgsAndValues = "";
  
real t;

// ********************************************************
//   Transform Multiplexer globals
typedef pair<ptrdiff_t, ptrdiff_t> _basis_pair;
typedef void (*transform_function)(bool, real, real* const __restrict__, real* const __restrict__, ptrdiff_t, ptrdiff_t);

// Less than operator needed by the C++ map class
struct _basis_pair_less_than
{
  bool operator()(const _basis_pair& _x, const _basis_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

struct _transform_step
{
  transform_function _func;
  bool _forward;
  bool _out_of_place;
  ptrdiff_t _prefix_lattice;
  ptrdiff_t _postfix_lattice;
};

// Structure to hold the basis change information
struct _basis_transform_t
{
  vector<_transform_step> _transform_steps;
  real _multiplier;
  
  _basis_transform_t(real _multiplier_in = 1.0) : _multiplier(_multiplier_in) {}
  
  _basis_transform_t(const _basis_transform_t& _b) : _transform_steps(_b._transform_steps), _multiplier(_b._multiplier) {}
  
  void append(transform_function _func, bool _forward, bool _out_of_place, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
  {
    _transform_steps.push_back((_transform_step){_func, _forward, _out_of_place, _prefix_lattice, _postfix_lattice});
  }
};

// Map type for holding (old_basis, new_basis) -> _basis_transform_t mappings
typedef map<_basis_pair, _basis_transform_t, _basis_pair_less_than> _basis_map;

_basis_map _x_wavefunction_basis_map;

real *_auxiliary_array = NULL;

const char *_basis_identifiers[] = {
  /* 0 */ "(kx)",
  /* 1 */ "(x)",
};

// ********************************************************
//   'Globals' element globals

#line 16 "transport.xmds"

        const real T = 3.0; // End time
const real x_0 = 3.0; // Final position

#line 297 "bec_transport.cc"

// ********************************************************
//   FFTW3 globals
const real _inverse_sqrt_2pi = 1.0 / sqrt(2.0 * M_PI); 
string _fftwWisdomPath;

// ********************************************************
//   Geometry globals
real* _x = NULL;

real* _kx = NULL;

// ********************************************************
//   field x globals
// vector wavefunction globals
size_t _x_wavefunction_alloc_size = 0;
complex* _x_wavefunction = NULL;
complex* _active_x_wavefunction = NULL;

ptrdiff_t _x_wavefunction_basis = -1;

// vector potential globals
size_t _x_potential_alloc_size = 0;
real* _x_potential = NULL;
real* _active_x_potential = NULL;

// ********************************************************
//   field dimensionless globals
// vector timing_function globals
size_t _dimensionless_timing_function_alloc_size = 0;
real* _dimensionless_timing_function = NULL;
real* _active_dimensionless_timing_function = NULL;

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) globals
complex* _segment1_akfield_x_wavefunction;
complex* _segment1_aifield_x_wavefunction;

// vector segment1_x_operators_operator0_field globals
size_t _x_segment1_x_operators_operator0_field_alloc_size = 0;
real* _x_segment1_x_operators_operator0_field = NULL;
real* _active_x_segment1_x_operators_operator0_field = NULL;

// ********************************************************
//   segment 2 (RK45 adaptive-step integrator) globals
complex* _segment2_akfield_x_wavefunction;
complex* _segment2_aifield_x_wavefunction;
complex* _segment2_ajfield_x_wavefunction;
complex* _segment2_alfield_x_wavefunction;
complex* _segment2_checkfield_x_wavefunction;

real _segment2_x_operators_operator0_last_timestep_size_map[5];

// vector segment2_x_operators_operator0_field globals
size_t _x_segment2_x_operators_operator0_field_alloc_size = 0;
complex* _x_segment2_x_operators_operator0_field = NULL;
complex* _active_x_segment2_x_operators_operator0_field = NULL;

// ********************************************************
//   field mg0_output globals
real* _mg0_output_t = NULL;
unsigned long _mg0_output_index_t = 0;

// vector raw globals
size_t _mg0_output_raw_alloc_size = 0;
real* _mg0_output_raw = NULL;
real* _active_mg0_output_raw = NULL;

// vector processed globals
size_t _mg0_output_processed_alloc_size = 0;
real* _mg0_output_processed = NULL;
real* _active_mg0_output_processed = NULL;
real* _mg0_output_sd = NULL;


// ********************************************************
// FUNCTION PROTOTYPES
// ********************************************************

// ********************************************************
//   Transform Multiplexer function prototypes
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);

// ********************************************************
//   field x function prototypes
void _x_wavefunction_initialise();
void _x_wavefunction_basis_transform(ptrdiff_t new_basis);

void _x_potential_initialise();

// ********************************************************
//   field dimensionless function prototypes
void _dimensionless_timing_function_evaluate();
void _dimensionless_timing_function_initialise();

// ********************************************************
//   segment 0 (Top level sequence) function prototypes
void _segment0();

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) function prototypes
inline void _segment1_calculate_delta_a(real _step);
inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent);
void _segment1();
inline void _segment1_ip_evolve(int _exponent);

void _segment1_x_operators_calculate_operator0_field();

void _segment1_x_operators_evaluate_operator1(real _step);

// ********************************************************
//   segment 2 (RK45 adaptive-step integrator) function prototypes
inline void _segment2_calculate_delta_a(real _step);
inline void _segment2_calculate_nonconstant_ip_fields(real _step, int _exponent);
void _segment2();
inline void _segment2_ip_evolve(int _exponent);
real _segment2_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter);
real _segment2_x_wavefunction_timestep_error(complex* _checkfield);
bool _segment2_x_wavefunction_reset(complex* _reset_to);

void _segment2_x_operators_calculate_operator0_field(real _step, int _exponent);

void _segment2_x_operators_evaluate_operator1(real _step);

// ********************************************************
//   output function prototypes
void _write_output();

FILE* _open_xsil_file(const char* _filename);
void _close_xsil_file(FILE*& fp);
void _write_xsil_header(FILE* fp);
void _write_xsil_footer(FILE* fp);

// ********************************************************
//   moment group 0 function prototypes
void _mg0_sample();
void _mg0_process();
void _mg0_write_out(FILE* _outfile);

// ********************************************************
//   field mg0_output function prototypes
void _mg0_output_raw_initialise();

void _mg0_output_processed_initialise();

// ********************************************************
// MAIN ROUTINE
// ********************************************************
int main(int argc, char **argv)
{
  #ifdef __APPLE__
    #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
  {
    IOPMAssertionID _powerAssertionID = 0;
    IOReturn __io_result = IOPMAssertionCreateWithDescription(
      kIOPMAssertionTypePreventUserIdleSystemSleep,
      CFSTR("XMDS simulation 'bec_transport' preventing user idle sleep"), // Assertion name
      NULL, // Assertion details
      NULL, // Human-readable reason
      NULL, // Localization bundle path
      (CFTimeInterval)0, // never timeout
      kIOPMAssertionTimeoutActionRelease,
      &_powerAssertionID
      );
    if (__io_result != kIOReturnSuccess) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to disable user idle sleep\n");
    }
    // Note, this power assertion is automatically released when the process quits.
  }
    #endif
  #endif
  
    
    
  
  _dimensionless_timing_function_alloc_size = MAX(_dimensionless_timing_function_alloc_size, (1) * _dimensionless_timing_function_ncomponents);
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_kx) * _x_wavefunction_ncomponents);
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_x) * _x_wavefunction_ncomponents);
  _x_potential_alloc_size = MAX(_x_potential_alloc_size, (_lattice_x) * _x_potential_ncomponents);
  _mg0_output_processed_alloc_size = MAX(_mg0_output_processed_alloc_size, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_processed_ncomponents);
  _mg0_output_raw_alloc_size = MAX(_mg0_output_raw_alloc_size, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_raw_ncomponents);
  _x_segment2_x_operators_operator0_field_alloc_size = MAX(_x_segment2_x_operators_operator0_field_alloc_size, (_lattice_kx) * _x_segment2_x_operators_operator0_field_ncomponents);
  _x_segment1_x_operators_operator0_field_alloc_size = MAX(_x_segment1_x_operators_operator0_field_alloc_size, (_lattice_kx) * _x_segment1_x_operators_operator0_field_ncomponents);
  _x = (real*) xmds_malloc(sizeof(real) * (_lattice_x+1));
  
  _kx = (real*) xmds_malloc(sizeof(real) * (_lattice_kx+1));
  
  _x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _active_x_wavefunction = _x_wavefunction;
  
  
  _x_potential = (real*) xmds_malloc(sizeof(real) * MAX(_x_potential_alloc_size,1));
  _active_x_potential = _x_potential;
  
  _dimensionless_timing_function = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_timing_function_alloc_size,1));
  _active_dimensionless_timing_function = _dimensionless_timing_function;
  _mg0_output_t = (real*) xmds_malloc(sizeof(real) * (_mg0_output_lattice_t+1));
  
  
  _mg0_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_raw_alloc_size,1));
  _active_mg0_output_raw = _mg0_output_raw;
  
  
  _mg0_output_processed = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_processed_alloc_size,1));
  _active_mg0_output_processed = _mg0_output_processed;
  _mg0_output_sd = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_processed_alloc_size,1)); // alias for _mg0_output_processed
  
  
  // Run-time validation checks
  
  if (T <= 0.0)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The interval for segment 2 is not positive!\n"
                           "Interval = %e\n", T);
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++)
    _x[_index_x] = _min_x + _index_x*_dx;
  for (long _index_kx = 0; _index_kx < (_lattice_kx+1)/2; _index_kx++)
    _kx[_index_kx] = _index_kx*_dkx;
  for (long _index_kx = (_lattice_kx+1)/2; _index_kx < _lattice_kx; _index_kx++)
    _kx[_index_kx] = -(_lattice_kx - _index_kx) * _dkx;
  _active_mg0_output_raw = _mg0_output_raw;
  _mg0_output_raw_initialise();
  
  _active_mg0_output_processed = _mg0_output_sd;
  _mg0_output_processed_initialise();
  _active_mg0_output_processed = _mg0_output_processed;
  _mg0_output_processed_initialise();
  // load wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX // Don't load wisdom on windows
  {
    char _hostName[256];
    gethostname(_hostName, 256);
    _hostName[255] = '\0'; // just in case
    
    string _pathToWisdom = getenv("HOME");
    _pathToWisdom += "/.xmds/wisdom/";
    
    string _wisdomFileName = _hostName;
    _wisdomFileName += ".wisdom";
    _wisdomFileName += ".fftw3";
    
    FILE *_fp = NULL;
    
    _fp = fopen(_pathToWisdom.c_str(), "r");
    if (_fp) {
      fclose(_fp);
    } else {
      int _result = mkdir((string(getenv("HOME")) + "/.xmds").c_str(), S_IRWXU);
      if (mkdir(_pathToWisdom.c_str(), S_IRWXU)) {
        // We failed to create the ~/.xmds/wisdom directory
        _LOG(_WARNING_LOG_LEVEL, "Warning: Cannot find enlightenment, the path to wisdom ~/.xmds/wisdom doesn't seem to exist and we couldn't create it.\n"
                                 "         I'll use the current path instead.\n");
        _pathToWisdom = ""; // present directory
      }
      
    }
    
    _fftwWisdomPath = _pathToWisdom + _wisdomFileName;
    
    FILE *_wisdomFile = NULL;
    if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "r")) != NULL) {
      _LOG(_SIMULATION_LOG_LEVEL, "Found enlightenment... (Importing wisdom)\n");
      fftw_import_wisdom_from_file(_wisdomFile);
      fclose(_wisdomFile);
    }
  }
  #endif // POSIX
  
  _basis_transform_t *_basis_transform = NULL;
  ptrdiff_t _auxiliary_array_size = 0;
  ptrdiff_t _max_vector_size = 0;
  real* _max_vector_array = NULL;
  
  if (2 * _x_wavefunction_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _x_wavefunction_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_x_wavefunction);
  }
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(0, 1)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dkx;
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ _lattice_x,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(1, 0)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dx;
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ _lattice_x,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents
  );
  
  if (_auxiliary_array_size) {
    _auxiliary_array = (real*) xmds_malloc(sizeof(real) * _auxiliary_array_size);
  }
  
  bool _allocated_temporary_array = false;
  if (!_max_vector_array && _max_vector_size > 0) {
    _max_vector_array = (real*) xmds_malloc(sizeof(real) * _max_vector_size);
    _allocated_temporary_array = true;
  }
  
  // Make all geometry-dependent transformations prepare plans, etc.
  _transform_0(true, 1.0, _max_vector_array, _auxiliary_array, 1, _x_wavefunction_ncomponents);
  
  if (_allocated_temporary_array) {
    xmds_free(_max_vector_array);
  }
  
  // Get the time at which the simulation started
  timeval _tim;
  gettimeofday(&_tim, NULL);
  double _startTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  
  /* Code that actually does stuff goes here */
  _segment0();
  
  
  _write_output();
  
  // Work out how long the simulation has run for
  gettimeofday(&_tim, NULL);
  double _endTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  _LOG(_SIMULATION_LOG_LEVEL, "Time elapsed for simulation is: %.2f seconds\n", _endTime - _startTime);
  if (_auxiliary_array) {
    xmds_free(_auxiliary_array);
  }
  
  // Save wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX
  {
    FILE *_wisdomFile = NULL;
    if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "w")) != NULL) {
      fftw_export_wisdom_to_file(_wisdomFile);
      fclose(_wisdomFile);
    }
  }
  #endif // POSIX
  
  fftw_cleanup();
  
  // Bing!
  _LOG(_SIMULATION_LOG_LEVEL, "\a");
  
  xmds_free(_x_wavefunction);
  _active_x_wavefunction = _x_wavefunction = NULL;
  
  
  xmds_free(_x_potential);
  _active_x_potential = _x_potential = NULL;
  
  xmds_free(_dimensionless_timing_function);
  _active_dimensionless_timing_function = _dimensionless_timing_function = NULL;
  
  xmds_free(_mg0_output_raw);
  _active_mg0_output_raw = _mg0_output_raw = NULL;
  
  
  xmds_free(_mg0_output_processed);
  _active_mg0_output_processed = _mg0_output_processed = NULL;
  xmds_free(_mg0_output_sd); // alias for _mg0_output_processed
  _mg0_output_sd = NULL;
  
  
  return 0;
}

// ********************************************************
// FUNCTION IMPLEMENTATIONS
// ********************************************************

inline void *xmds_malloc(size_t size)
{
  void *retPointer = _xmds_malloc(size);
  if ( !retPointer )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Couldn't allocate %zu bytes of memory!", size);
  return retPointer;
}


// ********************************************************
//   Transform Multiplexer function implementations
// x <---> kx transform
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  // _prefix_lattice should be 1
  // _postfix_lattice should be 1
  static fftw_plan _fftw_forward_plan = NULL;
  static fftw_plan _fftw_backward_plan = NULL;
  
  if (!_fftw_forward_plan) {
    _LOG(_SIMULATION_LOG_LEVEL, "Planning for x <---> kx transform...");
    
    fftw_iodim _transform_sizes[1], _loop_sizes[2];
    fftw_iodim *_iodim_ptr = NULL;
    
    int _transform_sizes_index = 0, _loop_sizes_index = 0;
    
    if (_prefix_lattice > 1) {
      _iodim_ptr = &_loop_sizes[_loop_sizes_index++];
      _iodim_ptr->n = _prefix_lattice;
      _iodim_ptr->is = _iodim_ptr->os = _postfix_lattice * _lattice_x;
    }
    if (_postfix_lattice > 1) {
      _iodim_ptr = &_loop_sizes[_loop_sizes_index++];
      _iodim_ptr->n = _postfix_lattice;
      _iodim_ptr->is = _iodim_ptr->os = 1;
    }
    _iodim_ptr = &_transform_sizes[_transform_sizes_index++];
    _iodim_ptr->n = _lattice_x;
    _iodim_ptr->is = _iodim_ptr->os = _postfix_lattice;
    
    
    _fftw_forward_plan = fftw_plan_guru_dft(
      _transform_sizes_index, _transform_sizes,
      _loop_sizes_index, _loop_sizes,
      reinterpret_cast<fftw_complex*>(_data_in), reinterpret_cast<fftw_complex*>(_data_in),
      FFTW_FORWARD, FFTW_PATIENT
    );
    if (!_fftw_forward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create forward dft plan.\n", __FILE__, __LINE__);
    
    _fftw_backward_plan = fftw_plan_guru_dft(
      _transform_sizes_index, _transform_sizes,
      _loop_sizes_index, _loop_sizes,
      reinterpret_cast<fftw_complex*>(_data_in), reinterpret_cast<fftw_complex*>(_data_in),
      FFTW_BACKWARD, FFTW_PATIENT
    );
    if (!_fftw_backward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create backward dft plan.\n", __FILE__, __LINE__);
    
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
  }
  
  if (_forward) {
    fftw_execute_dft(
      _fftw_forward_plan,
      reinterpret_cast<fftw_complex*>(_data_in),
      reinterpret_cast<fftw_complex*>(_data_in)
    );
  } else {
    fftw_execute_dft(
      _fftw_backward_plan,
      reinterpret_cast<fftw_complex*>(_data_in),
      reinterpret_cast<fftw_complex*>(_data_in)
    );
  }
}


// In-place multiply
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  #pragma ivdep
  for (long _i0 = 0; _i0 < _prefix_lattice * _postfix_lattice; _i0++) {
    _data_in[_i0] *= _multiplier;
  }
}

// ********************************************************
//   Multipath Simulation Driver function implementations
void _segment0()
{

  
  _x_segment1_x_operators_operator0_field = (real*) xmds_malloc(sizeof(real) * MAX(_x_segment1_x_operators_operator0_field_alloc_size,1));
  _active_x_segment1_x_operators_operator0_field = _x_segment1_x_operators_operator0_field;
  _segment1_akfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment1_aifield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  
  _x_segment2_x_operators_operator0_field = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_segment2_x_operators_operator0_field_alloc_size,1));
  _active_x_segment2_x_operators_operator0_field = _x_segment2_x_operators_operator0_field;
  _segment2_akfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment2_aifield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment2_ajfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment2_alfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment2_checkfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  
  memset(_segment2_x_operators_operator0_last_timestep_size_map, 0, sizeof(_segment2_x_operators_operator0_last_timestep_size_map));
  _segment1_x_operators_calculate_operator0_field();
  
  for (long _i0 = 0; _i0 < _n_paths; _i0+=1) {
    _LOG(_PATH_LOG_LEVEL, "Starting path %li\n", _i0 + 1);
  
    
    _mg0_output_raw_initialise();  
    t = 0.0;
    
    _mg0_output_raw_initialise();
    _active_x_wavefunction = _x_wavefunction;
    _x_wavefunction_initialise();
    _dimensionless_timing_function_evaluate();
    _active_x_potential = _x_potential;
    _x_potential_initialise();
    _mg0_output_index_t = 0;
    _segment1();
    _segment2();
    
    _mg0_process();
  }
  
  
  
  xmds_free(_x_segment1_x_operators_operator0_field);
  _active_x_segment1_x_operators_operator0_field = _x_segment1_x_operators_operator0_field = NULL;
  xmds_free(_segment1_akfield_x_wavefunction);
  xmds_free(_segment1_aifield_x_wavefunction);
  
  xmds_free(_x_segment2_x_operators_operator0_field);
  _active_x_segment2_x_operators_operator0_field = _x_segment2_x_operators_operator0_field = NULL;
  xmds_free(_segment2_akfield_x_wavefunction);
  xmds_free(_segment2_aifield_x_wavefunction);
  xmds_free(_segment2_ajfield_x_wavefunction);
  xmds_free(_segment2_alfield_x_wavefunction);
  xmds_free(_segment2_checkfield_x_wavefunction);

}


// ********************************************************
//   field x function implementations
// initialisation for vector wavefunction
void _x_wavefunction_initialise()
{
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in the initialisation
    // block of a <vector> element. If they're trying to do this, what they really want is a 
    // <computed_vector> instead.
    #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
    
    // ********** Initialisation code ***************
    #line 38 "transport.xmds"
    
    psi = 1.0 / pow(M_PI, 0.25) * exp(-pow(x, 2) / 2.0); // ground state of HO
    
    #line 862 "bec_transport.cc"
    // **********************************************
    #undef t
    
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef psi
  
  _x_wavefunction_basis = 1;
}


void _x_wavefunction_basis_transform(ptrdiff_t new_basis)
{
  if (_x_wavefunction_basis == new_basis)
    return;
  
  if (_x_wavefunction_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'x_wavefunction' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_x_wavefunction_basis_map.count(_basis_pair(_x_wavefunction_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'x_wavefunction' from basis %s to basis %s.\n",
      _basis_identifiers[_x_wavefunction_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _x_wavefunction_basis_map[_basis_pair(_x_wavefunction_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'x_wavefunction' from basis %s to basis %s.\n",
                           _basis_identifiers[_x_wavefunction_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_x_wavefunction);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _x_wavefunction_basis = new_basis;
}

// initialisation for vector potential
void _x_potential_initialise()
{
  
  long _x_potential_index_pointer = 0;
  #define V _active_x_potential[_x_potential_index_pointer + 0]
  long _dimensionless_timing_function_index_pointer = 0;
  #define lambda _active_dimensionless_timing_function[_dimensionless_timing_function_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in the initialisation
    // block of a <vector> element. If they're trying to do this, what they really want is a 
    // <computed_vector> instead.
    #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
    
    // ********** Initialisation code ***************
    #line 59 "transport.xmds"
    
    V = pow(x - lambda * x, 2) / 2.0;
    
    #line 942 "bec_transport.cc"
    // **********************************************
    #undef t
    
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_potential_index_pointer += 1 * _x_potential_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef V
  #undef lambda
}

// ********************************************************
//   field dimensionless function implementations
void _dimensionless_timing_function_evaluate()
{
  long _dimensionless_timing_function_index_pointer = 0;
  #define lambda _active_dimensionless_timing_function[_dimensionless_timing_function_index_pointer + 0]
  // ************* Evaluation code ****************
  #line 48 "transport.xmds"
  
  lambda = t / T;
  
  #line 967 "bec_transport.cc"
  // **********************************************
  #undef lambda
}


// initialisation for computed vector timing_function
void _dimensionless_timing_function_initialise()
{
}

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) function implementations
inline void _segment1_calculate_delta_a(real _step)
{
  
  
  // Delta A propagation operator for field x
  _segment1_x_operators_evaluate_operator1(_step);
  
}


inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent)
{
}


void _segment1()
{
  real _step = 5.0e-3/(real)10000;
  real _noiseStep = 5.0e-3/(real)10000;
  
  complex* _akfield_x_wavefunction = _segment1_akfield_x_wavefunction;
  complex* _aifield_x_wavefunction = _segment1_aifield_x_wavefunction;
  
  
  for (long _istep = 0; _istep < 10000; _istep++) {
    
    _x_wavefunction_basis_transform(1); // (x)
    
    // a_k = a
    memcpy(_akfield_x_wavefunction, _x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
    
    _segment1_calculate_nonconstant_ip_fields(_step, 1);
    
    // a = D[a]
    _segment1_ip_evolve(1);
    _x_wavefunction_basis_transform(1); // (x)
    
    // a_i = a
    memcpy(_aifield_x_wavefunction, _x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
    
    _active_x_wavefunction = _akfield_x_wavefunction;
      
    // a_k = G[a_k, t]
    _segment1_calculate_delta_a(_step);
    
    // a_k = D[a_k]
    _segment1_ip_evolve(1);
    _x_wavefunction_basis_transform(1); // (x)
    
    {
      _MAKE_AUTOVEC_VARIABLE(_akfield_x_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_aifield_x_wavefunction);
      #pragma ivdep
      for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
        // a = a + a_k/6
        _AUTOVEC(_x_wavefunction)[_i0] += _AUTOVEC(_akfield_x_wavefunction)[_i0]/6.0;
        // a_k = a_i + a_k/2
        _AUTOVEC(_akfield_x_wavefunction)[_i0] = _AUTOVEC(_aifield_x_wavefunction)[_i0] + 0.5*_AUTOVEC(_akfield_x_wavefunction)[_i0];
      }
    
    }
    
    t += 0.5*_step;
    
    // a_k = G[a_k, t + h/2]
    _segment1_calculate_delta_a(_step);
    _x_wavefunction_basis_transform(1); // (x)
    
    {
      _MAKE_AUTOVEC_VARIABLE(_akfield_x_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_aifield_x_wavefunction);
      #pragma ivdep
      for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
        // a = a + a_k/3
        _AUTOVEC(_x_wavefunction)[_i0] += _AUTOVEC(_akfield_x_wavefunction)[_i0]/3.0;
        // a_k = a_i + a_k/2
        _AUTOVEC(_akfield_x_wavefunction)[_i0] = _AUTOVEC(_aifield_x_wavefunction)[_i0] + 0.5*_AUTOVEC(_akfield_x_wavefunction)[_i0];
      }
    
    }
    
    // a_k = G[a_k, t + h/2]
    _segment1_calculate_delta_a(_step);
    _x_wavefunction_basis_transform(1); // (x)
    
    {
      _MAKE_AUTOVEC_VARIABLE(_akfield_x_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_aifield_x_wavefunction);
      #pragma ivdep
      for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
        // a = a + a_k/3
        _AUTOVEC(_x_wavefunction)[_i0] += _AUTOVEC(_akfield_x_wavefunction)[_i0]/3.0;
        // a_k = a_i + a_k
        _AUTOVEC(_akfield_x_wavefunction)[_i0] = _AUTOVEC(_aifield_x_wavefunction)[_i0] + _AUTOVEC(_akfield_x_wavefunction)[_i0];
      }
    
    }
    
    // a_k = D[a_k]
    _segment1_ip_evolve(1);
    
    t += 0.5*_step;
    
    // a_k = G[a_k, t + h]
    _segment1_calculate_delta_a(_step);
    _x_wavefunction_basis_transform(1); // (x)
    
    _active_x_wavefunction = _x_wavefunction;
    
    // a = D[a]
    _segment1_ip_evolve(1);
    _x_wavefunction_basis_transform(1); // (x)
    
    {
      _MAKE_AUTOVEC_VARIABLE(_akfield_x_wavefunction);
      _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
      #pragma ivdep
      for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
        // a = a + a_k/6
        _AUTOVEC(_x_wavefunction)[_i0] += _AUTOVEC(_akfield_x_wavefunction)[_i0]/6.0;
      }
    
    }
    
  }
  
  _SEGMENT1_END:;
  
}


inline void _segment1_ip_evolve(int _exponent)
{
  
  _x_wavefunction_basis_transform(0); // (kx)
  
  if (_exponent > 0) {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    
    long _x_segment1_x_operators_operator0_field_index_pointer = 0;
    for (long _i0 = 0; _i0 < (_lattice_kx); _i0++) {
      psi *= /* Ltt[psi] */ _x_segment1_x_operators_operator0_field[_x_segment1_x_operators_operator0_field_index_pointer + 0];
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
      _x_segment1_x_operators_operator0_field_index_pointer += _x_segment1_x_operators_operator0_field_ncomponents;
    }
    #undef psi
  } else {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    
    long _x_segment1_x_operators_operator0_field_index_pointer = 0;
    for (long _i0 = 0; _i0 < (_lattice_kx); _i0++) {
      psi /= /* Ltt[psi] */ _x_segment1_x_operators_operator0_field[_x_segment1_x_operators_operator0_field_index_pointer + 0];
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
      _x_segment1_x_operators_operator0_field_index_pointer += _x_segment1_x_operators_operator0_field_ncomponents;
    }
    #undef psi
  }
  
}

// ConstantIPOperator
void _segment1_x_operators_calculate_operator0_field()
{
  real _step = 5.0e-3/(real)10000;
  real _noiseStep = 5.0e-3/(real)10000;
  
  long _x_segment1_x_operators_operator0_field_index_pointer = 0;
  #define kx _kx[_index_kx + 0]
  #define dkx (_dkx * (1.0))
  
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    real Ltt;
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in a constant IP operator/
    // The user probably shouldn't be doing this, but if they must, they should use a non-constant EX
    // operator instead
    #define t Dont_use_propagation_dimension_t_in_constant_IP_operator___Use_non_constant_EX_operator_instead
    // ************** Operator code *****************
    #line 74 "transport.xmds"
    
    Ltt = -pow(kx, 2) / 2.0;
    
    #line 1169 "bec_transport.cc"
    // **********************************************
    #undef t
        
    _x_segment1_x_operators_operator0_field[_x_segment1_x_operators_operator0_field_index_pointer + 0] = exp(Ltt * 0.5 * _step);
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_segment1_x_operators_operator0_field_index_pointer += 1 * _x_segment1_x_operators_operator0_field_ncomponents;
    
  }
  #undef kx
  #undef dkx
}

// Delta A propagation operator for field x
void _segment1_x_operators_evaluate_operator1(real _step)
{
  // Transforming vectors to basis (x)
  _x_wavefunction_basis_transform(1); // (x)
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  long _x_potential_index_pointer = 0;
  #define V _active_x_potential[_x_potential_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    complex dpsi_dt;
    
    #define dt _step
    
    // ************* Propagation code ***************
    #line 78 "transport.xmds"
    
    dpsi_dt = 0.0 - (V + mod2(psi)) * psi;
    
    #line 1205 "bec_transport.cc"
    // **********************************************
    
    #undef dt
    
    
    _active_x_wavefunction[_x_wavefunction_index_pointer + 0] = dpsi_dt * _step;
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    _x_potential_index_pointer += 1 * _x_potential_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef psi
  #undef V
}

// ********************************************************
//   segment 2 (RK45 adaptive-step integrator) function implementations
inline void _segment2_calculate_delta_a(real _step)
{
  
  
  // Delta A propagation operator for field x
  _segment2_x_operators_evaluate_operator1(_step);
  
}


inline void _segment2_calculate_nonconstant_ip_fields(real _step, int _exponent)
{
  // NonConstantIPOperator
  _segment2_x_operators_calculate_operator0_field(_step, _exponent);
}


void _segment2()
{
  real _step = T/(real)1000;
  real _old_step = _step;
  real _min_step = _step;
  real _max_step = _step;
  long _attempted_steps = 0;
  long _unsuccessful_steps = 0;
  
  real _tolerance = 1e-08;
  
  real _error, _last_norm_error = 1.0;
  real _segment2_x_wavefunction_error;
  
  bool _discard = false;
  bool _break_next = false;
  
  bool _next_sample_flag[3];
  for (long _i0 = 0; _i0 < 3; _i0++)
    _next_sample_flag[_i0] = false;
  
  long _next_sample_counter[1];
  for (long _i0 = 0; _i0 < 1; _i0++)
    _next_sample_counter[_i0] = 1;
  
  real _t_local = 0.0;
  
  real _t_break_next = _segment2_setup_sampling(_next_sample_flag, _next_sample_counter);
  
  if ( (_t_local + _step)*(1.0 + _EPSILON) >= _t_break_next) {
    _break_next = true;
    _step = _t_break_next - _t_local;
  }
  
  complex* _akfield_x_wavefunction = _segment2_akfield_x_wavefunction;
  complex* _aifield_x_wavefunction = _segment2_aifield_x_wavefunction;
  complex* _ajfield_x_wavefunction = _segment2_ajfield_x_wavefunction;
  complex* _alfield_x_wavefunction = _segment2_alfield_x_wavefunction;
  complex* _checkfield_x_wavefunction = _segment2_checkfield_x_wavefunction;
  
  
  // Cash-Karp coefficients
  real _a_raw[7];
  real _a[7];
  real _b[7][7];
  real _c[7];
  real _cs[7];
  // linear combinations for the (k_i)s
  real _d[4];
  real _e[5];
  real _f[6];
  real _g[7];
  
  _a_raw[0]=0.0;
  _a_raw[1]=0.0;
  _a_raw[2]=1.0/5;
  _a_raw[3]=3.0/10;
  _a_raw[4]=3.0/5;
  _a_raw[5]=1.0;
  _a_raw[6]=7.0/8.0;
  
  _a[0]=0.0;
  _a[1]=0.0;
  for(long _i0 = 2; _i0 < 7; _i0++)
    _a[_i0] = _a_raw[_i0] - _a_raw[_i0-1];
  
  _b[2][1]=1.0/5;
  _b[3][1]=3.0/40;
  _b[3][2]=9.0/40;
  _b[4][1]=3.0/10;
  _b[4][2]=-9.0/10;
  _b[4][3]=6.0/5;
  _b[5][1]=-11.0/54;
  _b[5][2]=5.0/2;
  _b[5][3]=-70.0/27;
  _b[5][4]=35.0/27;
  _b[6][1]=1631.0/55296;
  _b[6][2]=175.0/512;
  _b[6][3]=575.0/13824;
  _b[6][4]=44275.0/110592;
  _b[6][5]=253.0/4096;
  
  _c[0]=0.0;
  _c[1]=37.0/378;
  _c[2]=0.0;
  _c[3]=250.0/621;
  _c[4]=125.0/594;
  _c[5]=0.0;
  _c[6]=512.0/1771;
  
  _cs[0]=0.0;
  _cs[1]=2825.0/27648;
  _cs[2]=0.0;
  _cs[3]=18575.0/48384;
  _cs[4]=13525.0/55296;
  _cs[5]=277.0/14336;
  _cs[6]=1.0/4;
  
  _d[0]=0.0;
  _d[1]=1.0-_b[3][1]/_c[1];
  _d[2]=_b[3][1]/_c[1];
  _d[3]=_b[3][2];
  
  _e[0]=0.0;
  _e[1]=1.0-_b[4][1]/_c[1];
  _e[2]=_b[4][1]/_c[1];
  _e[3]=_b[4][2];
  _e[4]=_b[4][3];
  
  _f[0]=0.0;
  _f[1]=1.0-_b[5][1]/_c[1];
  _f[2]=_b[5][1]/_c[1];
  _f[3]=_b[5][2];
  _f[4]=_b[5][3]-_b[5][1]/_c[1]*_c[3];
  _f[5]=_b[5][4]-_b[5][1]/_c[1]*_c[4];
  
  real _den=_c[1]*_cs[4]-_cs[1]*_c[4];
  _g[0]=0.0;
  _g[1]=( _b[6][4]*(_cs[1]-_c[1]) + _b[6][1]*(_c[4]-_cs[4]) )/_den + 1.0;
  _g[2]=  _b[6][2];
  _g[3]=( _b[6][4]*(_cs[1]*_c[3] - _c[1]*_cs[3]) + _b[6][1]*(_cs[3]*_c[4] - _c[3]*_cs[4]) )/_den + _b[6][3];
  _g[4]=( _b[6][1]*_cs[4]-_b[6][4]*_cs[1] )/_den;
  _g[5]=  _b[6][5] + _cs[5]*( _b[6][1]*_c[4]-_b[6][4]*_c[1] )/_den;
  _g[6]=( -_b[6][1]*_c[4]+_b[6][4]*_c[1] )/_den;
  
  do {
    
    do {
      
      _x_wavefunction_basis_transform(1); // (x)
      
      // a_k = y1
      memcpy(_akfield_x_wavefunction, _x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
      
      _segment2_calculate_nonconstant_ip_fields(_step, 1);
      
      // a_i = D(a_2*dt)[y1]
      _segment2_ip_evolve(1);
      _x_wavefunction_basis_transform(1); // (x)
      
      // y2 = y1
      memcpy(_checkfield_x_wavefunction, _x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
      
      // a_i = y1
      memcpy(_aifield_x_wavefunction, _x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
      
      _active_x_wavefunction = _akfield_x_wavefunction;
      
      // a_k = G[a_k, t]
      _segment2_calculate_delta_a(_step);
      
      // a_k = D(a_2*dt)[a_k]
      _segment2_ip_evolve(1);
      _x_wavefunction_basis_transform(1); // (x)
      
      {
        _MAKE_AUTOVEC_VARIABLE(_akfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_checkfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          // y1 = y1 + c_1*a_k
          _AUTOVEC(_x_wavefunction)[_i0] += _c[1]*_AUTOVEC(_akfield_x_wavefunction)[_i0];
          // y2 = y2 + cs_1*a_k
          _AUTOVEC(_checkfield_x_wavefunction)[_i0] += _cs[1]*_AUTOVEC(_akfield_x_wavefunction)[_i0];
          // a_k = a_i + b_21*a_k
          _AUTOVEC(_akfield_x_wavefunction)[_i0] = _AUTOVEC(_aifield_x_wavefunction)[_i0] + _b[2][1]*_AUTOVEC(_akfield_x_wavefunction)[_i0];
        }
      
      }
      
      t += _a[2] * _step;
      
      _segment2_calculate_nonconstant_ip_fields(_step, 2);
      
      _segment2_ip_evolve(-2);
      
      // a_k = G[a_k, t + aa_2*dt]
      _segment2_calculate_delta_a(_step);
      
      _segment2_ip_evolve(2);
      _x_wavefunction_basis_transform(1); // (x)
      
      // c_2 == cs_2 == 0
      {
        _MAKE_AUTOVEC_VARIABLE(_ajfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          // a_j = d_1*a_i + d_2*y1 + d_3*a_k
          _AUTOVEC(_ajfield_x_wavefunction)[_i0] = _d[1]*_AUTOVEC(_aifield_x_wavefunction)[_i0] + _d[2]*_AUTOVEC(_x_wavefunction)[_i0] + _d[3]*_AUTOVEC(_akfield_x_wavefunction)[_i0];
        }
      
      }
      
      t += _a[3] * _step;
      
      _active_x_wavefunction = _ajfield_x_wavefunction;
      
      _segment2_calculate_nonconstant_ip_fields(_step, 3);
      
      // a_j = D((a_3 - a_2)*dt)[a_j]
      _segment2_ip_evolve(-3);
      
      // a_j = G[a_j, t + aa_3*dt]
      _segment2_calculate_delta_a(_step);
      
      // a_j = D(-(a_3 - a_2)*dt)[a_j]
      _segment2_ip_evolve(3);
      _x_wavefunction_basis_transform(1); // (x)
      
      {
        _MAKE_AUTOVEC_VARIABLE(_ajfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_checkfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_alfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          // a_l = e_1*a_i + e_2*y1 + e_3*a_k + e_4*a_j
          _AUTOVEC(_alfield_x_wavefunction)[_i0] = _e[1]*_AUTOVEC(_aifield_x_wavefunction)[_i0] + _e[2]*_AUTOVEC(_x_wavefunction)[_i0] + _e[3]*_AUTOVEC(_akfield_x_wavefunction)[_i0] + _e[4]*_AUTOVEC(_ajfield_x_wavefunction)[_i0];
          // y1 = y1 + c_3*a_j
          _AUTOVEC(_x_wavefunction)[_i0] += _c[3]*_AUTOVEC(_ajfield_x_wavefunction)[_i0];
          // y2 = y2 + cs_3*a_j
          _AUTOVEC(_checkfield_x_wavefunction)[_i0] += _cs[3]*_AUTOVEC(_ajfield_x_wavefunction)[_i0];
        }
      
      }
      
      t += _a[4] * _step;
      
      _active_x_wavefunction = _alfield_x_wavefunction;
      
      _segment2_calculate_nonconstant_ip_fields(_step, 4);
      
      // a_l = D((a_4 - a_2)*dt)[a_l]
      _segment2_ip_evolve(-4);
      
      // a_l = G[a_l, t + aa_4*dt]
      _segment2_calculate_delta_a(_step);
      
      // a_l = D(-(a_4 - a_2)*dt)[a_l]
      _segment2_ip_evolve(4);
      _x_wavefunction_basis_transform(1); // (x)
      
      {
        _MAKE_AUTOVEC_VARIABLE(_ajfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_checkfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_alfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          // y1 = y1 + c_4*a_l
          _AUTOVEC(_x_wavefunction)[_i0] += _c[4]*_AUTOVEC(_alfield_x_wavefunction)[_i0];
          // y2 = y2 + cs_4*a_l
          _AUTOVEC(_checkfield_x_wavefunction)[_i0] += _cs[4]*_AUTOVEC(_alfield_x_wavefunction)[_i0];
          // a_l = f_1*a_i + f_2*y1 + f_3*a_k + f_4*a_j + f_5*a_l
          _AUTOVEC(_alfield_x_wavefunction)[_i0] = _f[1]*_AUTOVEC(_aifield_x_wavefunction)[_i0] + _f[2]*_AUTOVEC(_x_wavefunction)[_i0] + _f[3]*_AUTOVEC(_akfield_x_wavefunction)[_i0] + _f[4]*_AUTOVEC(_ajfield_x_wavefunction)[_i0] + _f[5]*_AUTOVEC(_alfield_x_wavefunction)[_i0];
        }
      
      }
      
      t += _a[5] * _step;
      
      // a_l = G[a_l, t + aa_5*dt]
      _segment2_calculate_delta_a(_step);
      _x_wavefunction_basis_transform(1); // (x)
      
      // c_5 == 0
      {
        _MAKE_AUTOVEC_VARIABLE(_ajfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_checkfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_alfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          // y2 = y2 + cs_5*a_l
          _AUTOVEC(_checkfield_x_wavefunction)[_i0] += _cs[5]*_AUTOVEC(_alfield_x_wavefunction)[_i0];
          // a_l = g_1*a_i + g_2*a_k + g_3*a_j + g_4*y_1 + g_5*a_l + g_6*y2
          _AUTOVEC(_alfield_x_wavefunction)[_i0] = _g[1]*_AUTOVEC(_aifield_x_wavefunction)[_i0] + _g[2]*_AUTOVEC(_akfield_x_wavefunction)[_i0] + _g[3]*_AUTOVEC(_ajfield_x_wavefunction)[_i0] + _g[4]*_AUTOVEC(_x_wavefunction)[_i0] + _g[5]*_AUTOVEC(_alfield_x_wavefunction)[_i0] + _g[6]*_AUTOVEC(_checkfield_x_wavefunction)[_i0];
        }
      
      }
      
      t += _a[6] * _step;
      
      _segment2_calculate_nonconstant_ip_fields(_step, 5);
      
      // a_l = D((a_6 - a_2)*dt)[a_l]
      _segment2_ip_evolve(-5);
      
      // a_l = G[a_l, t + aa_6*dt]
      _segment2_calculate_delta_a(_step);
      
      // a_l = D(-(a_6 - a_2)*dt)[a_l]
      _segment2_ip_evolve(5);
      _x_wavefunction_basis_transform(1); // (x)
      
      // c_5 == 0
      {
        _MAKE_AUTOVEC_VARIABLE(_alfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_checkfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          // y1 = y1 + c_6*a_l
          _AUTOVEC(_x_wavefunction)[_i0] += _c[6]*_AUTOVEC(_alfield_x_wavefunction)[_i0];
          // y2 = y2 + cs_6*a_l
          _AUTOVEC(_checkfield_x_wavefunction)[_i0] += _cs[6]*_AUTOVEC(_alfield_x_wavefunction)[_i0];
        }
      
      }
      
      // t -> t + dt
      t -= _a[6]*_step;
      
      _active_x_wavefunction = _checkfield_x_wavefunction;
      
      _active_x_wavefunction = _x_wavefunction;
      
      
      
      _error = 0.0;
      
      _segment2_x_wavefunction_error = _segment2_x_wavefunction_timestep_error(_checkfield_x_wavefunction);
      if (_segment2_x_wavefunction_error > _error)
        _error = _segment2_x_wavefunction_error;
      
      _attempted_steps++;
      
      if (_error < _tolerance) {
        _t_local += _step;
        if (_step > _max_step)
          _max_step = _step;
        if (!_break_next && _step < _min_step)
          _min_step = _step;
        _discard = false;
      } else {
        t -= _step;
  
        if (_segment2_x_wavefunction_reset(_aifield_x_wavefunction) == false) {
  
          _LOG(_WARNING_LOG_LEVEL, "WARNING: NaN present. Integration halted at t = %e.\n"
                             "         Non-finite number in integration vector \"wavefunction\" in segment 2.\n", t);
          if (_mg0_output_index_t < _mg0_output_lattice_t)
            _mg0_sample();
          
          goto _SEGMENT2_END;
        }
  
        _segment2_ip_evolve(-1);
        
        _discard = true;
        _break_next = false;
        _unsuccessful_steps++;
      }
      
      _old_step = _step;
      
      // Resize step
      if (_error < 0.5*_tolerance || _error > _tolerance) {
        const real _safetyFactor = 0.90;
        real _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-0.7/5.0)) * pow(_last_norm_error, real(0.4/5.0));
        _scalingFactor = MAX(_scalingFactor, 1.0/5.0);
        _scalingFactor = MIN(_scalingFactor, 7.0);
        if (_error > _tolerance && _scalingFactor > 1.0) {
          // If our step failed don't try and increase our step size. That would be silly.
          _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-1.0/5.0));
        }
        _old_step = _step;
        _last_norm_error = pow(_safetyFactor/_scalingFactor*pow(_last_norm_error, real(0.4/5.0)), real(5.0/0.7));
        _step *= _scalingFactor;
      }
      
    } while (_discard);
    
    if (_break_next) {
      if (_next_sample_flag[0]) {
        _mg0_sample();
        _next_sample_counter[0]++;
      }
      if (_next_sample_flag[1])
        _next_sample_flag[2] = true;
      else {
        _break_next = false;
        _t_break_next = _segment2_setup_sampling(_next_sample_flag, _next_sample_counter);
      }
    }
    
    if ( (_t_local + _step)*(1.0 + _EPSILON) > _t_break_next) {
      _break_next = true;
      _LOG(_SAMPLE_LOG_LEVEL, "Current timestep: %e\n", _old_step);
      _step = _t_break_next - _t_local;
    }
  } while (!_next_sample_flag[2]);
  
  _SEGMENT2_END:;
  
  _LOG(_SEGMENT_LOG_LEVEL, "Segment 2: minimum timestep: %e maximum timestep: %e\n", _min_step, _max_step);
  _LOG(_SEGMENT_LOG_LEVEL, "  Attempted %li steps, %.2f%% steps failed.\n", _attempted_steps, (100.0*_unsuccessful_steps)/_attempted_steps);
}


inline void _segment2_ip_evolve(int _exponent)
{
  unsigned long _segment2_x_operators_operator0_exponentIndex = (abs(_exponent) - 1) * 1;
  
  _x_wavefunction_basis_transform(0); // (kx)
  
  if (_exponent > 0) {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    
    long _x_segment2_x_operators_operator0_field_index_pointer = 0;
    for (long _i0 = 0; _i0 < (_lattice_kx); _i0++) {
      psi *= /* Ltt[psi] */ _x_segment2_x_operators_operator0_field[_x_segment2_x_operators_operator0_field_index_pointer + 0 + _segment2_x_operators_operator0_exponentIndex];
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
      _x_segment2_x_operators_operator0_field_index_pointer += _x_segment2_x_operators_operator0_field_ncomponents;
    }
    #undef psi
  } else {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    
    long _x_segment2_x_operators_operator0_field_index_pointer = 0;
    for (long _i0 = 0; _i0 < (_lattice_kx); _i0++) {
      psi /= /* Ltt[psi] */ _x_segment2_x_operators_operator0_field[_x_segment2_x_operators_operator0_field_index_pointer + 0 + _segment2_x_operators_operator0_exponentIndex];
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
      _x_segment2_x_operators_operator0_field_index_pointer += _x_segment2_x_operators_operator0_field_ncomponents;
    }
    #undef psi
  }
  
}
real _segment2_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter)
{
  // The numbers of the moment groups that need to be sampled at the next sampling point.
  // An entry of N+1 means "reached end of integration interval"
  long _momentGroupNumbersNeedingSamplingNext[2];
  long _numberOfMomentGroupsToBeSampledNext = 1;
  
  long _previous_m = 1;
  long _previous_M = 1;
  
  real _t_break_next = (real)T;
  _momentGroupNumbersNeedingSamplingNext[0] = 1;
  
  // initialise all flags to false
  for (long _i0 = 0; _i0 < 2; _i0++)
    _next_sample_flag[_i0] = false;
  
  /* Check if moment group needs sampling at the same time as another already discovered sample (or the final time).
   * If so, add this moment group to the to-be-sampled list. If moment group demands sampling earlier than all
   * previously noted moment groups, erase all previous ones from list and set the sample time to this earlier one.
   */
  if (_next_sample_counter[0] * _previous_M == _previous_m * 100) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = 0;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[0] * _previous_M < _previous_m * 100) {
    _t_break_next = _next_sample_counter[0] * ((real)T) / ((real)100);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = 0;
    _previous_M = 100;
    _previous_m = _next_sample_counter[0];
  }
  
  // _momentGroupNumbersNeedingSamplingNext now contains the complete list of moment groups that need
  // to be sampled at the next sampling point. Set their flags to true.
  for (long _i0 = 0; _i0 < _numberOfMomentGroupsToBeSampledNext; _i0++)
    _next_sample_flag[_momentGroupNumbersNeedingSamplingNext[_i0]] = true;
  
  return _t_break_next;
}

real _segment2_x_wavefunction_timestep_error(complex* _checkfield)
{
  real _error = 1e-24;
  real _temp_error = 0.0;
  real _temp_mod = 0.0;

  
  // Find the peak value for each component of the field
  real _cutoff[_x_wavefunction_ncomponents];
  
  for (long _i0 = 0; _i0 < _x_wavefunction_ncomponents; _i0++)
    _cutoff[_i0] = 0.0;
  
  {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_x); _i0++) {
      for (long _i1 = 0; _i1 < _x_wavefunction_ncomponents; _i1++) {
        _temp_mod = mod2(_x_wavefunction[_x_wavefunction_index_pointer + _i1]);
        if (_xmds_isnonfinite(_temp_mod))
          _cutoff[_i1] = INFINITY;
        else if (_cutoff[_i1] < _temp_mod)
          _cutoff[_i1] = _temp_mod;
      }
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
    }
    #undef psi
  }
  
  for (long _i0 = 0; _i0 < _x_wavefunction_ncomponents; _i0++) {
    if (_xmds_isnonfinite(_cutoff[_i0]))
      // Return an error two times the tolerance in this case because the timestep must be reduced.
      return 2.0*1e-08;
    _cutoff[_i0] *= 0.001;
    _cutoff[_i0] *= 0.001;
  }
  
  {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_x); _i0++) {
      for (long  _i1 = 0; _i1 < _x_wavefunction_ncomponents; _i1++) {
        if (mod2(_x_wavefunction[_x_wavefunction_index_pointer + _i1]) > _cutoff[_i1]) {
          _temp_error = abs(_x_wavefunction[_x_wavefunction_index_pointer + _i1] - _checkfield[_x_wavefunction_index_pointer + _i1]) / (0.5*abs(_x_wavefunction[_x_wavefunction_index_pointer + _i1]) + 0.5*abs(_checkfield[_x_wavefunction_index_pointer + _i1]));
          
          if (_xmds_isnonfinite(_temp_error)) {
            /* For _temp_error to be NaN, both the absolute value of the higher and lower order solutions
               must BOTH be zero. This therefore implies that their difference is zero, and that there is no error. */
            _temp_error = 0.0;
          }
          
          if (_error < _temp_error) // UNVECTORISABLE
            _error = _temp_error;
        }
      }
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
    }
    #undef psi
  }
  
  return _error;
}

bool _segment2_x_wavefunction_reset(complex* _reset_to_x_wavefunction)
{
  memcpy(_x_wavefunction, _reset_to_x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
  
  /* return false if there's a NaN somewhere in the vector, otherwise return true */
  bool bNoNaNsPresent = true;
  {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_x); _i0++) {
        for (long _i1 = 0; _i1 < _x_wavefunction_ncomponents; _i1++) {
          if (_xmds_isnonfinite(_x_wavefunction[_x_wavefunction_index_pointer + _i1].Re())
            || _xmds_isnonfinite(_x_wavefunction[_x_wavefunction_index_pointer + _i1].Im())) bNoNaNsPresent = false;
        }
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
    }
    #undef psi
  }
  return bNoNaNsPresent;
}

// NonConstantIPOperator
void _segment2_x_operators_calculate_operator0_field(real _step, int _exponent)
{
  static const real _propagationStepFractions[] = {
    1.0,
    4.0/5.0,
    7.0/10.0,
    2.0/5.0,
    1.0/8.0,
  };
  const long _arrayIndex = _exponent - 1;
  const real _propagationStepFraction = _propagationStepFractions[_arrayIndex];
  
  // If the timestep hasn't changed from the last time, then we're done.
  if (_propagationStepFraction * _step == _segment2_x_operators_operator0_last_timestep_size_map[_arrayIndex])
    return;
  
  long _x_segment2_x_operators_operator0_field_index_pointer = 0;
  #define kx _kx[_index_kx + 0]
  #define dkx (_dkx * (1.0))
  
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    complex Ltt;
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in a constant IP operator/
    // The user probably shouldn't be doing this, but if they must, they should use a non-constant EX
    // operator instead
    #define t Dont_use_propagation_dimension_t_in_constant_IP_operator___Use_non_constant_EX_operator_instead
    // ************** Operator code *****************
    #line 92 "transport.xmds"
    
    Ltt = -i * pow(kx, 2) / 2.0;
    
    #line 1846 "bec_transport.cc"
    // **********************************************
    #undef t
    
    _x_segment2_x_operators_operator0_field[_x_segment2_x_operators_operator0_field_index_pointer + _arrayIndex * 1 + 0] = cis(Ltt.Im() * _propagationStepFraction * _step);
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_segment2_x_operators_operator0_field_index_pointer += 1 * _x_segment2_x_operators_operator0_field_ncomponents;
    
  }
  #undef kx
  #undef dkx
  
  _segment2_x_operators_operator0_last_timestep_size_map[_arrayIndex] = _propagationStepFraction * _step;
}

// Delta A propagation operator for field x
void _segment2_x_operators_evaluate_operator1(real _step)
{
  // Transforming vectors to basis (x)
  _x_wavefunction_basis_transform(1); // (x)
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  long _x_potential_index_pointer = 0;
  #define V _active_x_potential[_x_potential_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    complex dpsi_dt;
    
    #define dt _step
    
    // ************* Propagation code ***************
    #line 96 "transport.xmds"
    
    dpsi_dt = 0.0 - i * (V + mod2(psi)) * psi;
    
    #line 1884 "bec_transport.cc"
    // **********************************************
    
    #undef dt
    
    
    _active_x_wavefunction[_x_wavefunction_index_pointer + 0] = dpsi_dt * _step;
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    _x_potential_index_pointer += 1 * _x_potential_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef psi
  #undef V
}

// ********************************************************
//   output function implementations
void _write_output()
{
  _LOG(_SIMULATION_LOG_LEVEL, "Generating output for bec_transport\n");
  
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", ("bec_transport" + gsArgsAndValues).c_str());
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", ("bec_transport" + gsArgsAndValues).c_str());
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  _mg0_write_out(_outfile);
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
}


FILE* _open_xsil_file(const char* _filename)
{
  
  FILE* fp = fopen(_filename, "w");
  
  if (fp == NULL)
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Unable to open output file '%s'.\n"
                           "Exiting.\n", _filename);
  
  return fp;
}

void _close_xsil_file(FILE*& fp)
{
  if (fp)
    fclose(fp);
  fp = NULL;
  
}

void _write_xsil_header(FILE* fp)
{
  if (!fp)
    return;
  fprintf(fp, "<?xml version=\"1.0\" ?><simulation xmds-version=\"2\">\n");
  fprintf(fp, "  <name>bec_transport</name>\n");
  fprintf(fp, "  <author>Jamie Feiss</author>\n");
  fprintf(fp, "  <description>\n");
  fprintf(fp, "    BEC transport test\n");
  fprintf(fp, "  </description>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <features>\n");
  fprintf(fp, "      <benchmark/>\n");
  fprintf(fp, "      <bing/>\n");
  fprintf(fp, "      <fftw plan=\"patient\"/>\n");
  fprintf(fp, "      <auto_vectorise/>\n");
  fprintf(fp, "      <validation kind=\"run-time\"/>\n");
  fprintf(fp, "      <globals>\n");
  fprintf(fp, "          <![CDATA[\n");
  fprintf(fp, "                    const real T = 3.0; // End time\n");
  fprintf(fp, "            const real x_0 = 3.0; // Final position\n");
  fprintf(fp, "          ]]>\n");
  fprintf(fp, "       </globals>\n");
  fprintf(fp, "     </features>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <!-- Number of trajectories (single processor) -->\n");
  fprintf(fp, "  <driver name=\"multi-path\" paths=\"10\"/>\n");
  fprintf(fp, "\n");
  fprintf(fp, "    <!-- Define dimensions -->\n");
  fprintf(fp, "    <geometry>\n");
  fprintf(fp, "        <propagation_dimension>t</propagation_dimension>\n");
  fprintf(fp, "        <transverse_dimensions>\n");
  fprintf(fp, "        <dimension domain=\"(-10, 10)\" lattice=\"64\" name=\"x\"/>\n");
  fprintf(fp, "        </transverse_dimensions>\n");
  fprintf(fp, "    </geometry>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <!-- Initialisation wavefunction -->\n");
  fprintf(fp, "  <vector dimensions=\"x\" name=\"wavefunction\" type=\"complex\">\n");
  fprintf(fp, "    <components>psi</components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "        psi = 1.0 / pow(M_PI, 0.25) * exp(-pow(x, 2) / 2.0); // ground state of HO\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <!-- Timing function -->\n");
  fprintf(fp, "  <computed_vector dimensions=\"\" name=\"timing_function\" type=\"real\">\n");
  fprintf(fp, "    <components>lambda</components>\n");
  fprintf(fp, "    <evaluation>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "        lambda = t / T;\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </evaluation>\n");
  fprintf(fp, "  </computed_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <!-- Harmonic trap potential -->\n");
  fprintf(fp, "  <vector dimensions=\"x\" name=\"potential\" type=\"real\">\n");
  fprintf(fp, "    <components>V</components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "                <dependencies>timing_function</dependencies>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "        V = pow(x - lambda * x, 2) / 2.0;\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <sequence>\n");
  fprintf(fp, "    <!-- Imaginary time to find ground state -->\n");
  fprintf(fp, "    <integrate algorithm=\"RK4\" interval=\"5.0e-3\" steps=\"10000\">\n");
  fprintf(fp, "      <samples>0</samples>\n");
  fprintf(fp, "      <operators>\n");
  fprintf(fp, "        <integration_vectors>wavefunction</integration_vectors>\n");
  fprintf(fp, "        <dependencies>potential</dependencies>\n");
  fprintf(fp, "        <operator constant=\"yes\" kind=\"ip\" type=\"real\">\n");
  fprintf(fp, "          <operator_names>Ltt</operator_names>\n");
  fprintf(fp, "          <![CDATA[\n");
  fprintf(fp, "            Ltt = -pow(kx, 2) / 2.0;\n");
  fprintf(fp, "          ]]>\n");
  fprintf(fp, "        </operator>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "          dpsi_dt = Ltt[psi] - (V + mod2(psi)) * psi;\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </operators>\n");
  fprintf(fp, "    </integrate>\n");
  fprintf(fp, "        \n");
  fprintf(fp, "        <!-- GPE -->\n");
  fprintf(fp, "        <integrate algorithm=\"ARK45\" interval=\"T\" tolerance=\"1e-8\">\n");
  fprintf(fp, "          <samples>100</samples>\n");
  fprintf(fp, "          <operators>\n");
  fprintf(fp, "            <integration_vectors>wavefunction</integration_vectors>\n");
  fprintf(fp, "            <dependencies>potential</dependencies>\n");
  fprintf(fp, "            <operator constant=\"yes\" kind=\"ip\" type=\"imaginary\">\n");
  fprintf(fp, "              <operator_names>Ltt</operator_names>\n");
  fprintf(fp, "              <![CDATA[\n");
  fprintf(fp, "                Ltt = -i * pow(kx, 2) / 2.0;\n");
  fprintf(fp, "              ]]>\n");
  fprintf(fp, "            </operator>\n");
  fprintf(fp, "            <![CDATA[\n");
  fprintf(fp, "              dpsi_dt = Ltt[psi] - i * (V + mod2(psi)) * psi;\n");
  fprintf(fp, "            ]]>\n");
  fprintf(fp, "          </operators>\n");
  fprintf(fp, "        </integrate>\n");
  fprintf(fp, "</sequence>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <output>\n");
  fprintf(fp, "      <sampling_group basis=\"x\" initial_sample=\"no\">\n");
  fprintf(fp, "        <moments>psi_real psi_imag density </moments>\n");
  fprintf(fp, "        <dependencies>wavefunction</dependencies>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "          psi_real = psi.Re();\n");
  fprintf(fp, "          psi_imag = psi.Im();\n");
  fprintf(fp, "          density = mod2(psi);\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </sampling_group>\n");
  fprintf(fp, "  </output>\n");
  
  fprintf(fp, "\n<info>\n");
  fprintf(fp, "Script compiled with XMDS2 version 2.2.3 \"It came from the deep\" (Debian package 2.2.3+dfsg-5)\n");
  fprintf(fp, "See http://www.xmds.org for more information.\n");
  fprintf(fp, "</info>\n");
  
}

// In addition to writing the footer (if 'fp' is not NULL)
// this function closes the fp file pointer.
void _write_xsil_footer(FILE* fp)
{
  if (fp) {
    fprintf(fp, "</simulation>\n");
  }
}

// ********************************************************
//   moment group 0 function implementations
void _mg0_sample()
{
  
  // Transforming vectors to basis (t, x)
  _x_wavefunction_basis_transform(1); // (x)
  
  long _mg0_output_raw_index_pointer = 0;
  #define psi_real _active_mg0_output_raw[_mg0_output_raw_index_pointer + 0]
  #define psi_imag _active_mg0_output_raw[_mg0_output_raw_index_pointer + 1]
  #define density _active_mg0_output_raw[_mg0_output_raw_index_pointer + 2]
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    // Set index pointers explicitly for (some) vectors
    _mg0_output_raw_index_pointer = ( 0
       + _mg0_output_index_t  * _lattice_x
       + _index_x * 1 ) * _mg0_output_raw_ncomponents;
    #define _SAMPLE_COMPLEX(variable) \
              variable ## R = variable.Re(); variable ## I = variable.Im();
    
    // *************** Sampling code ****************
    #line 107 "transport.xmds"
    
    psi_real = psi.Re();
    psi_imag = psi.Im();
    density = mod2(psi);
    
    #line 2118 "bec_transport.cc"
    // **********************************************
    
    #undef _SAMPLE_COMPLEX
    // Increment index pointers for vectors in field mg0_sampling (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef psi_real
  #undef psi_imag
  #undef density
  #undef psi
  
  _mg0_output_t[0 + _mg0_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #1) at t = %e\n", t);
  
}


void _mg0_process()
{
  {
    _MAKE_AUTOVEC_VARIABLE(_active_mg0_output_raw);
    _MAKE_AUTOVEC_VARIABLE(_active_mg0_output_processed);
    _MAKE_AUTOVEC_VARIABLE(_mg0_output_sd);
    #pragma ivdep
    for (long _i0 = 0; _i0 < (_mg0_output_lattice_t * _lattice_x) * _mg0_output_raw_ncomponents; _i0++) {
      _AUTOVEC(_active_mg0_output_processed)[_i0] += _AUTOVEC(_active_mg0_output_raw)[_i0];
      _AUTOVEC(_mg0_output_sd)[_i0] += _AUTOVEC(_active_mg0_output_raw)[_i0] * _AUTOVEC(_active_mg0_output_raw)[_i0];
    }
  
  }
}


void _mg0_write_out(FILE* _outfile)
{
  #pragma novector
  for (long _i0 = 0; _i0 < (_mg0_output_lattice_t * _lattice_x) * _mg0_output_processed_ncomponents; _i0++) {
    // Calculate the mean
    _active_mg0_output_processed[_i0] /= (real) _n_paths;
    
    // Calculate the standard error
    _mg0_output_sd[_i0] /= (real) _n_paths;
    _mg0_output_sd[_i0] -= _active_mg0_output_processed[_i0] * _active_mg0_output_processed[_i0];
    if (_mg0_output_sd[_i0] > 0.0) // UNVECTORISABLE
      _mg0_output_sd[_i0] = sqrt(_mg0_output_sd[_i0] / _n_paths);
    else
      _mg0_output_sd[_i0] = 0.0;
  }
  
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_1\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">2</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>8</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t x mean_psi_real mean_psi_imag mean_density stderr_psi_real stderr_psi_imag stderr_density \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg0_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_x);
    fprintf(_outfile, "    <Dim>8</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("bec_transport" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/1");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("bec_transport" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg0_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/1/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/1/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/1/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg0_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_x;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_x;
  if (!H5Lexists(hdf5_file, "/1/x", H5P_DEFAULT))
    dataset_x = H5Dcreate(hdf5_file, "/1/x", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_x = H5Dopen(hdf5_file, "/1/x");
  H5Dwrite(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _x);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_x, "x");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg0_output_lattice_t, _lattice_x};
  hid_t file_dataspace = H5Screate_simple(2, file_dims, NULL);
  
  hid_t dataset_mean_psi_real;
  if (!H5Lexists(hdf5_file, "/1/mean_psi_real", H5P_DEFAULT))
    dataset_mean_psi_real = H5Dcreate(hdf5_file, "/1/mean_psi_real", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mean_psi_real = H5Dopen(hdf5_file, "/1/mean_psi_real");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mean_psi_real, dataset_t, 0);
    H5DSattach_scale(dataset_mean_psi_real, dataset_x, 1);
  #endif
  hid_t dataset_mean_psi_imag;
  if (!H5Lexists(hdf5_file, "/1/mean_psi_imag", H5P_DEFAULT))
    dataset_mean_psi_imag = H5Dcreate(hdf5_file, "/1/mean_psi_imag", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mean_psi_imag = H5Dopen(hdf5_file, "/1/mean_psi_imag");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mean_psi_imag, dataset_t, 0);
    H5DSattach_scale(dataset_mean_psi_imag, dataset_x, 1);
  #endif
  hid_t dataset_mean_density;
  if (!H5Lexists(hdf5_file, "/1/mean_density", H5P_DEFAULT))
    dataset_mean_density = H5Dcreate(hdf5_file, "/1/mean_density", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mean_density = H5Dopen(hdf5_file, "/1/mean_density");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mean_density, dataset_t, 0);
    H5DSattach_scale(dataset_mean_density, dataset_x, 1);
  #endif
  hid_t dataset_stderr_psi_real;
  if (!H5Lexists(hdf5_file, "/1/stderr_psi_real", H5P_DEFAULT))
    dataset_stderr_psi_real = H5Dcreate(hdf5_file, "/1/stderr_psi_real", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_stderr_psi_real = H5Dopen(hdf5_file, "/1/stderr_psi_real");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_stderr_psi_real, dataset_t, 0);
    H5DSattach_scale(dataset_stderr_psi_real, dataset_x, 1);
  #endif
  hid_t dataset_stderr_psi_imag;
  if (!H5Lexists(hdf5_file, "/1/stderr_psi_imag", H5P_DEFAULT))
    dataset_stderr_psi_imag = H5Dcreate(hdf5_file, "/1/stderr_psi_imag", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_stderr_psi_imag = H5Dopen(hdf5_file, "/1/stderr_psi_imag");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_stderr_psi_imag, dataset_t, 0);
    H5DSattach_scale(dataset_stderr_psi_imag, dataset_x, 1);
  #endif
  hid_t dataset_stderr_density;
  if (!H5Lexists(hdf5_file, "/1/stderr_density", H5P_DEFAULT))
    dataset_stderr_density = H5Dcreate(hdf5_file, "/1/stderr_density", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_stderr_density = H5Dopen(hdf5_file, "/1/stderr_density");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_stderr_density, dataset_t, 0);
    H5DSattach_scale(dataset_stderr_density, dataset_x, 1);
  #endif
  H5Dclose(dataset_t);
  H5Dclose(dataset_x);
  
  
  if ((_mg0_output_lattice_t * _lattice_x)) {
    /* Create the data space */
    hsize_t file_start[2] = {0, 0};
    hsize_t mem_dims[3] = {_mg0_output_lattice_t, _lattice_x, 1};
    hsize_t mem_start[3] = {0, 0, 0};
    hsize_t mem_stride[3] = {1, 1, 1};
    hsize_t mem_count[3] = {_mg0_output_lattice_t, _lattice_x, 1};
    
    
    hid_t mem_dataspace;
    mem_dims[2] = 3;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 3;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mean_psi_real)
      H5Dwrite(dataset_mean_psi_real, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_processed);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mean_psi_imag)
      H5Dwrite(dataset_mean_psi_imag, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_processed);
    mem_start[2] = 2;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mean_density)
      H5Dwrite(dataset_mean_density, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_processed);
    
    H5Sclose(mem_dataspace);
    mem_dims[2] = 3;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 3;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_stderr_psi_real)
      H5Dwrite(dataset_stderr_psi_real, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _mg0_output_sd);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_stderr_psi_imag)
      H5Dwrite(dataset_stderr_psi_imag, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _mg0_output_sd);
    mem_start[2] = 2;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_stderr_density)
      H5Dwrite(dataset_stderr_density, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _mg0_output_sd);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_mean_psi_real);
  H5Dclose(dataset_mean_psi_imag);
  H5Dclose(dataset_mean_density);
  H5Dclose(dataset_stderr_psi_real);
  H5Dclose(dataset_stderr_psi_imag);
  H5Dclose(dataset_stderr_density);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg0_output function implementations
// initialisation for vector raw
void _mg0_output_raw_initialise()
{
  
  bzero(_active_mg0_output_raw, sizeof(real) * _mg0_output_raw_alloc_size);
}

// initialisation for vector processed
void _mg0_output_processed_initialise()
{
  
  bzero(_active_mg0_output_processed, sizeof(real) * _mg0_output_processed_alloc_size);
}

